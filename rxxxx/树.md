# 树形结构

[TOC]



## 树与森林

### 概念

类比树枝，不断延申，分化出多种分支；互不相干

位于最上方的点叫根结点，也是树的起源，类似于树根

每个结点连接的子结点数目称为“度”，各个结点的最大值称为整个树的“度”

每个结点延伸下去的下一个结点称为“子树”

每个结点的层次按照从上往下顺序，树的根结点为1，每向下一层+1，最大层次即为树的“深度”

与当前结点直接向下相连的结点称为“子结点”，反之则为“父结点”；若无子则成为“叶结点”

两个子结点为同一个父结点，则成为“兄弟结点”

父结点及父结点往上直到根节点，称为“祖先结点”

## 二叉树

- 满二叉树：度都为2，整棵树都非常饱满，所有叶结点都有同样的深度


- 完全二叉树：在满二叉树中，最后一层，从右向左连续缺若干结点（类似于三角形的右边角切了个梯形）

  典型应用：堆

- 非完全二叉树：




### 树和森林的转换

#### 规律

1. 最左边的孩子结点->左子树结点
2. 兄弟结点->右子树结点（右孩子）

#### 二叉树变为普通的树



#### 森林转换为二叉树

连接每一棵树时，一律从根节点的右边开始，不断向右连接。

在森林转换为二叉树时，根结点就存在右子树了，右子树连接的是森林中的其他树

### 二叉树的性质

性质一：第i层的最大结点数量为2的（i-1）次方

性质二：对于一棵深度为k的二叉树，可以具有的最大结点数量为：n=2^0^+...+2^(k-1)^

性质三：假设一棵二叉树的中度为0、1、2的结点数量为k,i,j ； 则结点总数为n=k+i+j

性质四：完全二叉树除了最后一层有空缺，其他无空。那么一颗完全二叉树的结点数n满足
$$
2^k/2<=n<=2^k-1
$$
性质五：一颗有n个结点的完全二叉树深度为k=log2n+1，现在对于任何一个结点i，结点的顺序从上往下，从左往右

- 对于一个拥有左右孩子的结点来说，其左孩子为2i，右孩子为  2i+1
- 如果 i=1，那么此结点为二叉树的根结点，i<1 ，那么其父结点就是 i/2.比如第三个结点的父结点就是第一个结点，也就是根结点
- 如果 2i>n，则结点 i 没有左孩子，
- 如果 2i+1>n, 则结点 i 没有右孩子

### 二叉树的构建

二叉树的存储

数组



#### 链式结构

```c
#include <stdio.h>
#include <malloc.h>

typedef char E;

typedef struct treenode{
    E element;
    struct treenode *left; //左孩子＋右孩子
    struct treenode *right;
} * node;

int main(){
    node a=malloc(sizeof(struct treenode)); //创造结点
    node b=malloc(sizeof(struct treenode));
    node c =malloc(sizeof(struct treenode));
    node d =malloc(sizeof(struct treenode));
    node e =malloc(sizeof(struct treenode));
    a->element='A'; //连上
    b->element='B';
    c->element='C';
    d->element='D';
    e->element='E';
    a->left=b;
    b->right=c;
    d->left=d;
    b->right=e;
    c->left=c->right=NULL;
    d->left=d->right=NULL;
    e->right=e->left=NULL;
    printf("%c",a->left->right->element);
}
```



## 二叉树的遍历

### 前序遍历

打印根结点->前序遍历左子树->前序遍历右子树

假设从根节点开始编号，则先最小编号左子树到最大编号，再到左结点相连最大编号右子树到最小

##### 递归

```c
void preorder(node root){
    if(root == NULL)  return;
    printf("%c",root->element);
    preorder(root->left);
    preorder(root->right);
}
```

非递归

```c
typedef char E;

struct TreeNode {
    E element;
    struct TreeNode * left;
    struct TreeNode * right;
};

typedef struct TreeNode * Node;

//栈 
typedef Node T; 

struct StackNode {
    T element;
    struct StackNode * next;
};

typedef struct StackNode * SNode; 

void initStack(SNode head){
    head->next = NULL;
}

_Bool pushStack(SNode head, T element){
    SNode node = malloc(sizeof(struct StackNode));
    if(node == NULL) return 0;
    node->next = head->next;
    node->element = element;
    head->next = node;
    return 1;
}

_Bool isEmpty(SNode head){
    return head->next == NULL;
}

T popStack(SNode head){
    SNode top = head->next;
    head->next = head->next->next;
    T e = top->element;
    free(top);
    return e;
}

//-------------------------------------

void preOrder(Node root){
    struct StackNode stack;  
    initStack(&stack);
    while (root || !isEmpty(&stack)){   //两个条件，只有当栈空并且节点为NULL时才终止循环
        while (root) {    //按照我们的思路，先不断遍历左子树，直到没有为止
            pushStack(&stack, root);   //途中每经过一个结点，就将结点丢进栈中
            printf("%c", root->element);   //然后打印当前结点元素值
            root = root->left;  //继续遍历下一个左孩子结点
        }
        root = popStack(&stack);  //经过前面的循环，明确左子树全部走完了，接着就是右子树了
        root = root->right;  //得到右孩子，如果有右孩子，下一轮会重复上面的步骤；如果没有右孩子那么这里的root就被赋值为NULL了，下一轮开始会直接跳过上面的while，继续出栈下一个结点再找右子树
    }
}
```



### 中序遍历

首先不断遍历左子树，走到最底部，在进行沿途有右子树就打印右子树

<img src="D:\self\pic\t-middle" alt="image-20230406220807374" style="zoom:80%;" />

递归

```c
void inOrder(Node root){
    if(root == NULL) return;
    inOrder(root->left);  //先完成全部左子树的遍历
    printf("%c", root->element);   //等待左子树遍历完成之后再打印
    inOrder(root->right);   //然后就是对右子树进行遍历
}
```

非递归

```c
void inOrder(Node root){
    struct StackNode stack;
    initStack(&stack);
    while (root || !isEmpty(&stack)){   //其他都不变
        while (root) {
            pushStack(&stack, root);
            root = root->left;
        }
        root = popStack(&stack);
        printf("%c", root->element);   //只需要将打印时机延后到左子树遍历完成
        root = root->right;
    }
}
```



### 后序遍历

与前序遍历规律相反，结果不一定相反

<img src="D:\self\pic\image-20230406221307263.png" alt="image-20230406221307263" style="zoom:67%;" />

递归

```
void postOrder(Node root){
    if(root == NULL) return;
    postOrder(root->left);
    postOrder(root->right);
    printf("%c", root->element);   //时机延迟到最后
}
```

非递归

```c
T peekStack(SNode head){   //这里新增一个peek操作，用于获取栈顶元素的值，但是不出栈，仅仅是值获取
    return head->next->element;
}

void postOrder(Node root){
    struct StackNode stack;
    initStack(&stack);
    while (root || !isEmpty(&stack)){   //其他都不变
        while (root) {
            pushStack(&stack, root);
            root->flag = 0;    //首次入栈时，只能代表左子树遍历完成，所以flag置0
            root = root->left;
        }
        root = peekStack(&stack);   //注意这里只是获取到结点，并没有进行出栈操作，因为需要等待右子树遍历完才能出栈
        if(root->flag == 0) {    //如果仅仅遍历了左子树，那么flag就等于0
            root->flag = 1;   //此时标记为1表示遍历右子树
            root = root->right;   //这里跟之前是一样的
        } else {
            printf("%c", root->element);   //当flag为1时走这边，此时左右都遍历完成了，这时再打印值出来
            popStack(&stack);   //这时再把对应的结点出栈，因为左右都完事了
            root = NULL;   //置为NULL，下一轮直接跳过while，然后继续取栈中剩余的结点，重复上述操作
        }
    }
}
```



### 层序遍历

一层一层，从左到右

```c
typedef char E;

struct TreeNode {
    E element;
    struct TreeNode * left;
    struct TreeNode * right;
    int flag;
};

typedef struct TreeNode * Node;

//--------------- 队列 ----------------
typedef Node T;   //还是将Node作为元素

struct QueueNode {
    T element;
    struct QueueNode * next;
};

typedef struct QueueNode * QNode;

struct Queue{
    QNode front, rear;
};

typedef struct Queue * LinkedQueue;

_Bool initQueue(LinkedQueue queue){ //init
    QNode node = malloc(sizeof(struct QueueNode));
    if(node == NULL) return 0;
    queue->front = queue->rear = node;
    return 1;
}

_Bool offerQueue(LinkedQueue queue, T element){ //push
    QNode node = malloc(sizeof(struct QueueNode));
    if(node == NULL) return 0;
    node->element = element;
    queue->rear->next = node;
    queue->rear = node;
    return 1;
}

_Bool isEmpty(LinkedQueue queue){
    return queue->front == queue->rear;
}

T pollQueue(LinkedQueue queue){
    T e = queue->front->next->element;
    QNode node = queue->front->next;
    queue->front->next = queue->front->next->next;
    if(queue->rear == node) queue->rear = queue->front;
    free(node);
    return e;
}

void levelOrder(Node root){
    struct Queue queue;   //先搞一个队列
    initQueue(&queue);
    offerQueue(&queue, root);  //先把根节点入队
    while (!isEmpty(&queue)) {   //不断重复，直到队列空为止
        Node node = pollQueue(&queue);   //出队一个元素，打印值
        printf("%c", node->element);
        //如果存在左右孩子的话
        if(node->left)    
            offerQueue(&queue, node->left);  //注意顺序，先左后右
        if(node->right)
            offerQueue(&queue, node->right);
    }
}
```





## 逆波兰表达式 L.150

```
bool isNumber(char* token) {
    return strlen(token) > 1 || ('0' <= token[0] && token[0] <= '9');
}

int evalRPN(char** tokens, int tokensSize) {
    int n = tokensSize;
    int stk[n], top = 0;
    for (int i = 0; i < n; i++) {
        char* token = tokens[i];
        if (isNumber(token)) {
            stk[top] = atoi(token); //文字转数字
            top++;
        } else {
            --top;
            int num2 = stk[top];
            --top;
            int num1 = stk[top];
            switch (token[0]) {
                case '+':
                    stk[top] = num1 + num2;
                    top++;
                    break;
                case '-':
                    stk[top] = num1 - num2;
                    top++;
                    break;
                case '*':
                    stk[top] = num1 * num2;
                    top++;
                    break;
                case '/':
                    stk[top] = num1 / num2;
                    top++;
                    break;
            }
        }
    }
    return stk[top - 1];
}
```

