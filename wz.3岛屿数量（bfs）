#include <stdio.h>

struct node {
	int x, y;
};

struct node que[90005];
int n, m;
int e[305][305], book[305][305];

int next[4][2] = {{0, 1}, {1, 0}, {0, -1}, {-1, 0}};

int main() {
	int i, j, k, tx, ty;
	scanf("%d %d", &n, &m);
	for (i = 1; i <= n; i++)
		for (j = 1; j <= m; j++)
			scanf("%d", &e[i][j]);
	int head = 1, tail = 1, ans = 0;
	for (i = 1; i <= n; i++) {
		for (j = 1; j <= m; j++) {
			//如果这个点没走过，并且这个点是海洋
			if (book[i][j] == 0 && e[i][j] == 0)
				book[i][j] = 1;
			//如果这个点走过了
			if (book[i][j] == 1)
				continue;
			//如果这个点没走过&&并且这个点是陆地
			if (book[i][j] == 0 && e[i][j] == 1) {
				ans++;
				que[tail].x = i;
				que[tail].y = j;
				book[i][j] = 1;
				tail++;
				while (head < tail) {
					for (k = 0; k <= 3; k++) {
						tx = que[head].x + next[k][0];
						ty = que[head].y + next[k][1];
						//判断是否出界
						if (tx < 1 || tx > n || ty < 1 || ty > m)
							continue;
						//未出界
						if (tx >= 1 && tx <= n && ty >= 1 && ty <= m) {
							//如果这个点没走过&&并且这个点是陆地,那就将这个点入列
							if (book[tx][ty] == 0 && e[tx][ty] == 1) {
								que[tail].x = tx;
								que[tail].y = ty;
								book[tx][ty] = 1;
								tail++;
							} else
								continue;
						}
					}
					head++;
				}
			}
		}
	}
	printf("%d", ans);
	return 0;
}
