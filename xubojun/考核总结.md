# 考核总结

删除链表的中间节点

```
/**
 * Definition for singly-linked list.
 * struct ListNode {
 *     int val;
 *     struct ListNode *next;
 * };
 */


struct ListNode* deleteMiddle(struct ListNode* head){
    int len=0;
    struct ListNode *t;
    t=head;
    while(t!=NULL){
        t=t->next;
        len++;
    }
    if(len==1)
    return NULL;
    int x=len/2;
    struct ListNode* p,*q;
    p=head;
    for(int i=0;i<x;i++){
        q=p;
        p=p->next;
    }
    q->next=p->next;
    return head;
}
```

括号的最大深度嵌套深度

```
int maxDepth(char * s){
    //if(s[0]=='('&&s[1]==')') return 1;
    int len=strlen(s);
    int st=0;
    int i=0;
    int max=0;
    while(i<len||st!=0){
        if(s[i]=='('){
            st++;
            i++;
            if(max<st) max=st;
            continue;
        }
        else if(s[i]==')'){
            st--;
            i++;
            if(max<st) max=st;
            continue;
        }
        if(max<st) max=st;   
        i++;
    }
    return max;
}
```

有序数组的平方

```
/**
 * Note: The returned array must be malloced, assume caller calls free().
 */
void quicksort(int* arr,int left,int right){
	int i=left,j=right;
	int mid=arr[(left+right)/2];
	do{
		while(arr[i]<mid)
		i++;
		while(arr[j]>mid)
		j--;
		if(i<=j){
			int t=arr[i];
			arr[i]=arr[j];
			arr[j]=t;
			i++;j--;
		}
	}while(i<=j);
	if(left<j) quicksort(arr,left,j);
	if(i<right) quicksort(arr,i,right);
	return;
}
int* sortedSquares(int* nums, int numsSize, int* returnSize){
    *returnSize=numsSize;
    int* arr=(int *)malloc(sizeof(int)*numsSize);
    int i;
    for(i=0;i<numsSize;i++){
        arr[i]=nums[i]*nums[i];
    }
    quicksort(arr,0,numsSize-1);
    return arr;
}
```

盛最多水的容器

```
int maxArea(int* height, int heightSize){
    int i,j,h;
    int max=0,t;
    for(i=0,j=heightSize-1;i<j;){
        if(height[i]<=height[j]){
            h=height[i];
            t=(j-i)*h;
            if(t>max) max=t;
            i++;
            continue;
        }
        else{
            h=height[j];
            t=(j-i)*h;
            if(t>max) max=t;
            j--;
            continue;
        }
    }
    return max;
}
```

压缩字符串

```
int compress(char* chars, int charsSize){
    int i=0,j,repeat,start,end,used;
    char ch;
    int len=0;
    char *ret=(char *)malloc(sizeof(char)*charsSize);
    while(i<charsSize){
        ret[len++]=chars[i];
        repeat=1;
        j=i+1;
        while(j<charsSize&&chars[j]==chars[i]){
            repeat++;
            j++;
        }
        used=repeat;
        if(repeat>1){
            start=len;
            while(repeat){
                ret[len++]=repeat%10+'0';
                repeat=repeat/10;
            }
            end=len-1;
            while(start<end){
                ch=ret[start];
                ret[start]=ret[end];
                ret[end]=ch;
                start++;
                end--;
            }
        }
        i+=used;
    }
    memcpy(chars,ret,sizeof(char)*len);
    return len;
}
```

