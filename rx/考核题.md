# 考核复盘

## [11.盛最多水的容器](https://leetcode.cn/problems/container-with-most-water/)

### 原始思路

我们称纵坐标为宽度，横坐标为长度

数组中的数的没有递增递减的规律的，但是在整个过程中，长度是递减的，所以就以这个为切入，因为长度自然是越长越好，所以先设置``left``和``right``从两边开始

从一开始先找一个标准边``h``，那么我们的愿望就是，在长度损失最小的情况下，找到一个``>=``该标准边的存在，即可选定下一条标准边了

理想状态下，每条标准边能达成的最大水量即是``h*(height.length - left)``

在标准边的选定，由于是从左往右进行选择的，长度也是在递减的，所以如果标准边比上一条小，那也是没有必要在进行计算的。

### 原始代码

```c
int maxArea(int* height, int heightSize){
    int max = 0;
    int result;
    int height_max;
    int height_left_max = height[0];
    int right;
    for(int i=0;i<heightSize-1;i++) {
        if(height_left_max > height[i]) {
            continue;
        }
        height_left_max = height[i];
        right = heightSize - 1;
        height_max = height[right];
        
        while(right >i) {
            if(height[right] < height_max) {
                if(height_max >= height_left_max) {
                    break;
                }
                right--;
                continue;
            }
            height_max = height[right];
            if(height[right] > height[i]) {
                result = height[i]*(right-i);
            } else {
                result = height[right]*(right-i);
            }
            if(max < result) {
                max = result;
            }
            right--;
        }
    }
    return max;
}
```

### 改进思路

因为这样做出来的时间复杂度极其高，所以参考了LeetCode的标准答案，发现了不同，两者答案都是在以长度递减为基础，但是在之后标准边的选择上出现了不同。

当``height[left] != heiht[right]``时，下一步应该去找寻的是和较大的那一条边更贴近的边，以达到在长度减小时，盛水量也能出现增加的可能

这较原始思路就减少了很多不必要的比较。非常的优雅。

### 改进代码

```c
int maxArea(int* height, int heightSize){
    int left = 0, right = heightSize -1;
    int max = 0, tmp = 0;

    while (left < right) {
        if (height[left] < height[right]) {
            tmp = height[left] * (right - left);
            left++;
        } else {
            tmp = height[right] * (right - left);
            right--;
        }
        if (tmp > max) max = tmp;
    }

    return max;
}
```



## [443.压缩字符串](https://leetcode.cn/problems/string-compression/)

### 思路

直接在``chars``数组中进行修改，当选定字母不是只有一个的时候，就需要一个数字反映数量。因此，思路主要是设置一个``write``、一个``count``指针，一个用于定位下一个需要操作的字母，另一个数数。

易出错点：溢出问题，很容易在判断时，末尾多溢出一个

### 代码

```c
void swap(char *a, char *b) {
    char t = *a;
    *a = *b;
    *b = t;
}

void reverse(char *a, char *b) {
    while (a < b) {
        b--;
        swap(a, b);
        a++;
        
    }
}

int compress(char *chars, int charsSize) {
    int write = 0;
    int left = 0;
    for (int read = 0; read < charsSize; read++) {
        if (read == charsSize - 1 || chars[read] != chars[read + 1]) {
            chars[write] = chars[read];
            write++;
            int num = read - left + 1;
            if (num > 1) {
                int anchor = write;
                while (num > 0) {
                    chars[write] = num % 10 + '0';
                    write++;
                    num /= 10;
                }
                reverse(&chars[anchor], &chars[write]);
            }
            left = read + 1;
        }
    }
    return write;
}
```

