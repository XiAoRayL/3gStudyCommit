//括号的最大嵌套深度
int maxDepth(char * s){
   int len = strlen(s);
   int i = 0;
   int ans = 0;
   int size = 0;
   for(i=0;i<len;++i){
       char a = s[i];
       if(a=='('){
           ++size;
           ans = fmax(ans,size);
       }else if(a==')'){
           --size;
       }
   }
   return ans;
}
//有序数组的平方
int* sortedSquares(int* nums, int numsSize, int* returnSize){
   int left = 0;
   int* result = (int*)malloc(sizeof(int)*numsSize);
   int i=numsSize-1;
   int right = numsSize-1;
   while (left <= right) {
        int leftSquare = nums[left] * nums[left];
        int rightSquare = nums[right] * nums[right];
        if (leftSquare > rightSquare) {
            result[i--] = leftSquare;
            left++;
        } else {
            result[i--] = rightSquare;
            right--;
        }
    }

    *returnSize = numsSize;
    return result;
}
//压缩字符串
int compress(char* chars, int charsSize) {
    int left = 0, right = 0, write = 0;
    while (right < charsSize) {
        if (right == charsSize - 1 || chars[right] != chars[right + 1]) {
            chars[write++] = chars[right];
            int count = right - left + 1;
            if (count > 1) {
                char str[10];
                int len = sprintf(str, "%d", count);
                for (int i = 0; i < len; i++) {
                    chars[write++] = str[i];
                }
            }
            left = right + 1;
        }
        right++;
    }
    return write;
}
//盛最多水的容器
int maxArea(int* height, int heightSize){
       int left= 0;
       int right = heightSize-1;
       int max = -100;
       
       while(left<right){
           int len = right-left;
           int sum = 0;
           if(height[left]>height[right]){
               sum = height[right]*len;
               --right;
           }else if(height[left]<=height[right]){
               sum = height[left]*len;
               ++left;
           }
           if(sum>max){
               max = sum;
           }
       }
       return max;
}
//删除链表中间节点
int length(struct ListNode* head){
    int len = 0;
    struct ListNode* p = head;
    while(p){
        ++len;
        p = p->next;
    }
    return len;
}
struct ListNode* deleteMiddle(struct ListNode* head){
    if(head==NULL){
        return head;
    }
    int k = 0;
    k = length(head);
    if(k==1){
        return NULL;
    }
    int mid;
    mid = k/2;;
    // if(k%2==0){
    //     mid = k/2;
    // }else{
    //     mid = (k/2);
    //     }
        struct ListNode* p = head;
        int len = 0;
        while(len<mid-1){
            p = p->next;
            ++len;
        }
        struct ListNode* q = p->next;
        if(p->next!=NULL)
        p->next = q->next;
        
        
        return head;
}

